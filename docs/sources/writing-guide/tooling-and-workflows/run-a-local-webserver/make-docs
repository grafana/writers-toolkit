#!/usr/bin/env bash
# Source of this file is https://github.com/grafana/technical-documentation/scripts/make-docs.

set -ef -o pipefail

readonly DOCS_CONTAINER="${DOCS_CONTAINER:-make-docs}"
readonly DOCS_HOST_PORT="${DOCS_HOST_PORT:-3002}"
readonly DOCS_IMAGE="${DOCS_IMAGE:-grafana/docs-base:latest}"

readonly HUGO_REFLINKSERRORLEVEL="${HUGO_REFLINKSERRORLEVEL:-WARNING}"

# ANSI codes.
readonly BLUE='\e[1;34m'
readonly END='\e[0m'
readonly RED='\e[1;31m'
readonly YELLOW='\e[1;33m'

PODMAN="$(if command -v podman &>/dev/null; then echo podman; else echo docker; fi)"
readonly PODMAN

function about {
  cat <<EOF
Test documentation locally with multiple source repositories.

The REPOS_PATH environment variable is a colon (:) separated list of paths in which to look for project repositories.
EOF
}

function usage {
  cat <<EOF
Usage:
  REPOS_PATH=<PATH[:<PATH>...]> $0 [<PROJECT>[:<VERSION>[:<REPO>[:<DIR>]]]...]

Examples:
  REPOS_PATH=~/ext/grafana/ $0 writers-toolkit tempo:latest helm-charts/mimir-distributed:latest:mimir:docs/sources/mimir-distributed
EOF
}

if [[ $# -lt 1 ]]; then
  cat <<EOF >&2
ERROR: arguments required but not supplied.

$(about)

$(usage)
EOF
  exit 1
fi

readonly REPOS_PATH="${REPOS_PATH:-$(realpath "$(git rev-parse --show-toplevel)/..")}"

if [[ -z "${REPOS_PATH}" ]]; then
  cat <<EOF >&2
ERROR: REPOS_PATH environment variable is required but has not been provided.

$(usage)
EOF
  exit 1
fi

declare -A SOURCES
SOURCES['enterprise-metrics']='backend-enterprise'
SOURCES['grafana-cloud']='cloud-docs'
SOURCES['helm-charts/mimir-distributed']='mimir'
SOURCES['helm-charts/tempo-distributed']='tempo'

declare -A VERSIONS
VERSIONS['grafana-cloud']='UNVERSIONED'
VERSIONS['opentelemetry']='UNVERSIONED'
VERSIONS['writers-toolkit']='UNVERSIONED'

declare -A PATHS
PATHS['helm-charts/mimir-distributed']='docs/sources/helm-charts/mimir-distributed'
PATHS['helm-charts/tempo-distributed']='docs/sources/helm-charts/tempo-distributed'
PATHS['mimir']='docs/sources/mimir'
PATHS['tempo']='docs/sources/tempo'

# proj_complete_structure fills any empty fields.
function proj_complete_structure {
  local -r project="$1"
  local version="$2"
  local repo="$3"
  local path="$4"

  # If version is not set, use the script mapping of project to default versions if it exists.
  # Fallback to 'latest'.
  if [[ -z "${version}" ]]; then
    if [[ -z "${VERSIONS[${project}]}" ]]; then
      version=latest
    else
      version="${VERSIONS[${project}]}"
    fi
  fi
  readonly version

  # If repo is not set, use the script mapping of project to repo name if it exists.
  # Fallback to using the project name.
  if [[ -z "${repo}" ]]; then
    if [[ -z "${SOURCES[${project}]}" ]]; then
      repo="${project}"
    else
      repo="${SOURCES[${project}]}"
    fi
  fi
  readonly repo

  # If path is not set, use the script mapping of project to docs sources path if it exists.
  # Fallback to using 'docs/sources'.
  if [[ -z "${path}" ]]; then
    if [[ -z "${PATHS[${project}]}" ]]; then
      path="docs/sources"
    else
      path="${PATHS[${project}]}"
    fi
  fi
  readonly path

  echo "${project}:${version}:${repo}:${path}"
}

# proj_url returns the webserver URL for a project.
# It expects a complete project structure as input.
function proj_url {
  IFS=: read -r project version _ _ <<<"$1"

  if [[ -z "${version}" ]] || [[ "${version}" == 'UNVERSIONED' ]]; then
    echo "http://localhost:3002/docs/${project}/"
  else
    echo "http://localhost:3002/docs/${project}/${version}/"
  fi
}

# proj_ver returns the version for a project.
# It expects a complete project structure as input.
function proj_ver {
  IFS=: read -r _ ver _ _ <<<"$1"
  echo "${ver}"
}

# proj_dst returns the container path to content source for a project.
# It expects a complete project structure as input.
function proj_dst {
  IFS=: read -r project version _ _ <<<"$1"

  if [[ -z "${version}" ]] || [[ "${version}" == 'UNVERSIONED' ]]; then
    echo "/hugo/content/docs/${project}"
  else
    echo "/hugo/content/docs/${project}/${version}"
  fi
}

# proj_src returns the host path to content source for a project.
# It expects a complete project structure as input.
# It looks for the provided repository name in each of the paths specified in the REPOS_PATH environment variable.
function proj_src {
  IFS=: read -r _ _ repo path <<<"$1"

  for lookup in IFS=: "${REPOS_PATH[@]}"; do
    if [[ -d "${lookup}/${repo}" ]]; then
      echo "${lookup}/${repo}/${path}"
      return
    fi

  done

  echo "ERROR: could not find project '${repo}' in any of the paths in REPOS_PATH ${REPOS_PATH}."
  return 1
}

function proj_to_url_src_dst_ver {
  echo "$(proj_url "$1")^$(proj_src "$1")^$(proj_dst "$1")^$(proj_ver "$1")"
}

function url_src_dst_vers {
  for arg in "$@"; do
    IFS=: read -r project version repo path <<<"${arg}"
    case "${project}" in
      # Workaround for arbitrary mounts where the version field is expected to be the local directory
      # and the repo field is expected to be the container directory.
      arbitrary)
        echo "${project}^${version}^${repo}^" # TODO
        ;;
      logs)
        proj_to_url_src_dst_ver "$(proj_complete_structure loki "${version}")"
        proj_to_url_src_dst_ver "$(proj_complete_structure enterprise-logs "${version}")"
        ;;
      metrics)
        proj_to_url_src_dst_ver "$(proj_complete_structure mimir "${version}")"
        proj_to_url_src_dst_ver "$(proj_complete_structure helm-charts/mimir-distributed "${version}")"
        proj_to_url_src_dst_ver "$(proj_complete_structure enterprise-metrics "${version}")"
        ;;
      traces)
        proj_to_url_src_dst_ver "$(proj_complete_structure tempo "${version}")"
        proj_to_url_src_dst_ver "$(proj_complete_structure enterprise-traces "${version}")"
        ;;
      *)
        proj_to_url_src_dst_ver "$(proj_complete_structure "${project}" "${version}" "${repo}" "${path}")"
        ;;
    esac
  done
}

url_src_dst_vers="$(url_src_dst_vers "$@")"

declare -a volumes
declare -a redirects
for x in ${url_src_dst_vers}; do
  IFS='^' read -r url src dst ver <<<"${x}"

  if [[ -n "$(git -C "${src}" status --porcelain)" ]]; then
    echo -e "${YELLOW}WARN${END} Repository '$(git -C "${src}" rev-parse --show-toplevel)' worktree is dirty" >&2
  fi

  if [[ "${url}" != "arbitrary" ]]; then
    if [[ ! -f "${src}/_index.md" ]]; then
      echo -e "${RED}ERRR${END} Index file '${src}/_index.md' does not exist." >&2
      echo "Is '${src}' the correct source directory?" >&2
      continue
    fi
  fi

  echo -e "${BLUE}DEBG${END} Mounting '${src}' at container path '${dst}'" >&2
  volumes+=("--volume=${src}:${dst}")

  if [[ -n "${ver}" ]]; then
    redirects+=("${dst}^${ver}")
  fi
done

cat <<EOF >/tmp/make-docs-entrypoint
#!/usr/bin/env bash
for redirect in ${redirects[@]}; do
  IFS='^' read -r path ver <<<"\${redirect}"
  echo -e "---\\nredirectURL: \"\${path/\/hugo\/content/}\"\\ntype: redirect\\n---\\n" > "\${path/${ver}/_index.md}"

  make server
done
EOF
chmod +x /tmp/make-docs-entrypoint
volumes+=("--volume=/tmp/make-docs-entrypoint:/entrypoint")
readonly volumes

echo
echo "Documentation will be served at the following URLs:"
for x in ${url_src_dst_vers}; do
  IFS='^' read -r url _ _ <<<"${x}"
  if [[ -n "${url}" ]]; then
    echo "  ${url}"
  fi
done

echo
"${PODMAN}" run \
  --env "HUGO_REFLINKSERRORLEVEL=${HUGO_REFLINKSERRORLEVEL}" \
  --init \
  --interactive \
  --name "${DOCS_CONTAINER}" \
  --platform linux/amd64 \
  --publish "3002:${DOCS_HOST_PORT}" \
  --rm \
  --tty \
  "${volumes[@]}" \
  "${DOCS_IMAGE}" \
  /entrypoint
